// src/components/progress/_styles.scss
@use '../../styles/abstract/base' as base;
@use '../../styles/abstract/variables' as v;
@use '../../styles/abstract/functions' as f;
@use '../../styles/abstract/mixins' as m;
@use '../../styles/abstract/theme' as t;
@use 'sass:math';

$component: '#{base.$prefix}-progress';

// Material Design 3 spec constants
$linear-height: 4px;
$circular-size: 48px;
$stroke-width: 6px;
$linear-gap-size: 8px;
$circular-gap-size: 4px;

// Keyframes for SVG-based indeterminate linear progress
@keyframes indeterminate-bar {
  0% {
    x2: 0; 
    transform: translateX(-12%);
    stroke-width: $linear-height;
  }
  50% {
    x2: 33;
    stroke-width: $linear-height;
  }
  100% {
    x2: 12;
    transform: translateX(112%);
    stroke-width: $linear-height;
  }
}

.#{$component} {
  // Base styles
  position: relative;
  display: block;
  overflow: hidden;
  
  // Common accessibility attributes
  &[aria-disabled="true"] {
    opacity: 0.38;
    pointer-events: none;
  }

  // Linear progress variant - MD3 specs
  &--linear {
    width: 100%;
    height: $linear-height; // MD3 spec height
    min-height: $linear-height; // Ensure minimum height
    border-radius: calc($linear-height / 2);
    
    // For SVG-based linear progress
    svg {
      overflow: visible; // Allow portions to extend outside container if needed
      width: 100%;
      height: $linear-height; // Match the container height
      min-height: $linear-height; // Ensure minimum height
      display: block; // Prevent any inline display issues
      
      line, .#{$component}-track, .#{$component}-buffer, .#{$component}-indicator, .#{$component}-remaining {
        // Ensure all line elements have the proper height
        stroke-width: $linear-height;
        // Force visibility
        vector-effect: non-scaling-stroke;
        transition: stroke-dasharray 0.3s ease, stroke-dashoffset 0.3s ease, x1 0.3s ease, x2 0.3s ease;
      }
      
      .#{$component}-track {
        stroke: t.color('surface-container-highest');
        stroke-width: $linear-height;
        stroke-linecap: round;
      }
      
      .#{$component}-buffer {
        stroke: t.alpha('primary', 0.4);
        stroke-width: $linear-height;
        stroke-linecap: round;
        transition: all 0.3s ease;
      }
      
      .#{$component}-indicator {
        stroke: t.color('primary');
        stroke-width: $linear-height;
        stroke-linecap: round;
        transition: all 0.3s ease;
      }
      
      .#{$component}-remaining {
        stroke: t.alpha('primary', 0.24);
        stroke-width: $linear-height;
        stroke-linecap: round;
        transition: all 0.3s ease;
      }
    }
    
    // Legacy non-SVG styling for backwards compatibility
    // Track - the "remaining" part (lighter color)
    .#{$component}-track:not(line) {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: t.color('surface-container-highest');
      border-radius: calc($linear-height / 2);
      z-index: 0; // Lowest layer
    }
    
    // Buffer element for "buffering" scenarios (video loading, etc.)
    .#{$component}-buffer:not(line) {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0;
      background-color: t.alpha('primary', 0.4);
      transition: width 0.3s ease;
      border-radius: calc($linear-height / 2);
    }
    
    // Indicator - the "active" part (primary color)
    .#{$component}-indicator:not(line) {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0;
      background-color: t.color('primary');
      transition: width 0.3s ease;
      border-radius: calc($linear-height / 2);
      z-index: 2; // Higher than remaining and track
    }
    
    // Remaining - the space between indicator and 100%
    .#{$component}-remaining:not(line) {
      position: absolute;
      top: 0;
      height: 100%;
      // Left and width are set programmatically
      background-color: t.alpha('primary', 0.24);
      border-radius: calc($linear-height / 2);
      transition: left 0.3s ease, width 0.3s ease, margin-left 0.3s ease;
      z-index: 1; // Lower than indicator but higher than track
      box-sizing: border-box; // Ensure consistent sizing
    }
    
    // Indeterminate animation for linear progress
    &.#{$component}--indeterminate {
      .#{$component}-buffer, .#{$component}-buffer:not(line) {
        display: none;
      }
      
      // For SVG elements
      svg {
        .#{$component}-track {
          opacity: 1 !important; // Force track visibility in indeterminate mode
        }
        
        .#{$component}-indicator {
          // Position the SVG line with initial width
          x1: 0;
          x2: 40%; // Initial width is 40% of container
          // Set transform origin for scaling and translation
          transform-origin: left center;
          // Apply combined animation
          animation: linear-indeterminate 2s infinite linear;
        }
        
        .#{$component}-remaining {
          display: none;
        }
      }
      
      // For legacy non-SVG elements
      .#{$component}-indicator:not(line) {
        width: 0; // Initial width
        animation: 
          linear-indeterminate-translate 1.7s infinite linear,
          linear-indeterminate-width 1.7s infinite ease-in-out;
        border-radius: calc($linear-height / 2);
        z-index: 2;
      }
      
      .#{$component}-remaining:not(line) {
        display: block;
        width: 100%;
      }
    }
    
    // Label element
    .#{$component}-label {
      position: absolute;
      right: 0;
      top: calc($linear-height + 4px); // Position below the progress bar
      font-size: 12px;
      color: t.color('on-surface-variant');
    }
  }

      // Circular progress variant
  &--circular {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: $circular-size;
    height: $circular-size;
    
    svg {
      width: 100%;
      height: 100%;
      transform: rotate(-90deg);
    }
    
    .#{$component}-track {
      stroke: t.color('surface-container-highest');
      fill: none;
      stroke-width: $stroke-width;
      // Track is hidden by default in determinate mode
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .#{$component}-indicator {
      stroke: t.color('primary');
      fill: none;
      stroke-width: $stroke-width;
      // Use round stroke-linecap as specified
      stroke-linecap: round;
      transform-origin: center;
      transition: stroke-dasharray 0.3s ease, stroke-dashoffset 0.3s ease, transform 0.3s ease;
    }
    
    .#{$component}-remaining {
      stroke: t.alpha('primary', 0.24);
      fill: none;
      stroke-width: $stroke-width;
      // Use round stroke-linecap as specified
      stroke-linecap: round;
      transform-origin: center;
      transition: stroke-dasharray 0.3s ease, stroke-dashoffset 0.3s ease, transform 0.3s ease;
    }
    
    // Indeterminate animation for circular progress
    &.#{$component}--indeterminate {
      .#{$component}-track {
        opacity: 1; // Show track in indeterminate mode
      }
      
      .#{$component}-indicator {
        stroke-dasharray: 283; // 2*PI*45 (full circumference)
        animation: circular-indeterminate 1.5s linear infinite;
      }
      
      .#{$component}-remaining {
        display: none;
      }
    }
    
    .#{$component}-label {
      position: absolute;
      font-size: 12px;
      color: t.color('on-surface-variant');
    }
  }
  
  // Disabled state
  &--disabled {
    opacity: 0.38;
    pointer-events: none;
  }
}

// Keyframes for indeterminate animations

@keyframes circular-indeterminate {
  0% {
    stroke-dashoffset: 283;
  }
  50% {
    stroke-dashoffset: 70;
  }
  100% {
    stroke-dashoffset: 283;
    transform: rotate(360deg);
  }
}

@keyframes linear-indeterminate {
  0% {
    transform: translateX(-10%) scaleX(0); // Start off-screen left, zero width
  }
  25% {
    transform: translateX(20%) scaleX(0.40); // Near middle, 20% width (0.5 * 40%)
  }
  50% {
    transform: translateX(50%) scaleX(0.50); // Past middle, shrinking
  }
  75% {
    transform: translateX(80%) scaleX(0.25); // Near end, zero width
  }
  100% {
    transform: translateX(110%) scaleX(0); // Off-screen right, zero width
  }
}